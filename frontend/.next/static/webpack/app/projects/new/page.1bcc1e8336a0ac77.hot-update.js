"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projects/new/page",{

/***/ "(app-pages-browser)/./hooks/useProjectSession.ts":
/*!************************************!*\
  !*** ./hooks/useProjectSession.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProjectSession: function() { return /* binding */ useProjectSession; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useProjectSession = ()=>{\n    const [sessionId, setSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [projectData, setProjectData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentStep, setCurrentStep] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [completedSteps, setCompletedSteps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const autoSaveTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const createSession = async function() {\n        let initialData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        setLoading(true);\n        setError(null);\n        try {\n            const response = await fetch(\"/api/project-session\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    projectData: initialData,\n                    currentStep: 1,\n                    completedSteps: []\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to create session\");\n            }\n            const { sessionId } = await response.json();\n            setSessionId(sessionId);\n            setProjectData(initialData);\n            setCurrentStep(1);\n            setCompletedSteps([]);\n            // Store session ID in localStorage\n            localStorage.setItem(\"projectSessionId\", sessionId);\n            return sessionId;\n        } catch (error) {\n            console.error(\"Error creating session:\", error);\n            setError(error.message);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const updateSession = async (data, step)=>{\n        if (!sessionId) return;\n        setLoading(true);\n        setError(null);\n        try {\n            const updatedData = {\n                ...projectData,\n                ...data\n            };\n            setProjectData(updatedData);\n            const response = await fetch(\"/api/project-session\", {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    sessionId,\n                    projectData: updatedData,\n                    currentStep: step,\n                    completedSteps: [\n                        ...completedSteps,\n                        step\n                    ]\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to update session\");\n            }\n            setCurrentStep(step);\n            setCompletedSteps((prev)=>Array.from(new Set([\n                    ...prev,\n                    step\n                ])));\n        } catch (error) {\n            console.error(\"Error updating session:\", error);\n            setError(error.message);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const loadSession = async (id)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const response = await fetch(\"/api/project-session/\".concat(id));\n            if (!response.ok) {\n                if (response.status === 404) {\n                    // Session not found, create new one\n                    console.log(\"Session not found, creating new session\");\n                    localStorage.removeItem(\"projectSessionId\");\n                    await createSession();\n                    return;\n                } else if (response.status === 410) {\n                    // Session expired, create new one\n                    console.log(\"Session expired, creating new session\");\n                    localStorage.removeItem(\"projectSessionId\");\n                    await createSession();\n                    return;\n                }\n                throw new Error(\"Failed to load session: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            const session = await response.json();\n            setSessionId(session.sessionId);\n            setProjectData(session.projectData);\n            setCurrentStep(session.currentStep);\n            setCompletedSteps(session.completedSteps);\n        } catch (error) {\n            console.error(\"Error loading session:\", error);\n            setError(error.message);\n            // Fallback to new session\n            localStorage.removeItem(\"projectSessionId\");\n            await createSession();\n        } finally{\n            setLoading(false);\n        }\n    };\n    const clearSession = async ()=>{\n        if (sessionId) {\n            try {\n                await fetch(\"/api/project-session/\".concat(sessionId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error clearing session:\", error);\n            }\n            localStorage.removeItem(\"projectSessionId\");\n            setSessionId(null);\n            setProjectData(null);\n            setCurrentStep(1);\n            setCompletedSteps([]);\n            setError(null);\n        }\n    };\n    const autoSave = (data)=>{\n        // Clear existing timeout\n        if (autoSaveTimeout.current) {\n            clearTimeout(autoSaveTimeout.current);\n        }\n        // Set new timeout for auto-save\n        autoSaveTimeout.current = setTimeout(()=>{\n            if (sessionId && data) {\n                updateSession(data, currentStep).catch(console.error);\n            }\n        }, 1000); // 1 second delay\n    };\n    // Cleanup timeout on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (autoSaveTimeout.current) {\n                clearTimeout(autoSaveTimeout.current);\n            }\n        };\n    }, []);\n    return {\n        sessionId,\n        projectData,\n        currentStep,\n        completedSteps,\n        loading,\n        error,\n        createSession,\n        updateSession,\n        loadSession,\n        clearSession,\n        autoSave,\n        setCurrentStep,\n        setProjectData\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVByb2plY3RTZXNzaW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRDtBQW1DN0MsTUFBTUcsb0JBQW9CO0lBQy9CLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHTCwrQ0FBUUEsQ0FBZ0I7SUFDMUQsTUFBTSxDQUFDTSxhQUFhQyxlQUFlLEdBQUdQLCtDQUFRQSxDQUF5QjtJQUN2RSxNQUFNLENBQUNRLGFBQWFDLGVBQWUsR0FBR1QsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDVSxnQkFBZ0JDLGtCQUFrQixHQUFHWCwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ2pFLE1BQU0sQ0FBQ1ksU0FBU0MsV0FBVyxHQUFHYiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNjLE9BQU9DLFNBQVMsR0FBR2YsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU1nQixrQkFBa0JkLDZDQUFNQSxDQUF3QjtJQUV0RCxNQUFNZSxnQkFBZ0I7WUFBT0MsK0VBQXdDLENBQUM7UUFDcEVMLFdBQVc7UUFDWEUsU0FBUztRQUVULElBQUk7WUFDRixNQUFNSSxXQUFXLE1BQU1DLE1BQU0sd0JBQXdCO2dCQUNuREMsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQm5CLGFBQWFZO29CQUNiVixhQUFhO29CQUNiRSxnQkFBZ0IsRUFBRTtnQkFDcEI7WUFDRjtZQUVBLElBQUksQ0FBQ1MsU0FBU08sRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1SLFNBQVNTLElBQUk7Z0JBQ3JDLE1BQU0sSUFBSUMsTUFBTUYsVUFBVWIsS0FBSyxJQUFJO1lBQ3JDO1lBRUEsTUFBTSxFQUFFVixTQUFTLEVBQUUsR0FBRyxNQUFNZSxTQUFTUyxJQUFJO1lBQ3pDdkIsYUFBYUQ7WUFDYkcsZUFBZVc7WUFDZlQsZUFBZTtZQUNmRSxrQkFBa0IsRUFBRTtZQUVwQixtQ0FB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VSxDQUFDO1lBQ3hCekMsYUFBYTtZQUNiRSxlQUFlO1lBQ2ZFLGVBQWU7WUFDZkUsa0JBQWtCLEVBQUU7WUFDcEJJLFNBQVM7UUFDWDtJQUNGO0lBRUEsTUFBTW1DLFdBQVcsQ0FBQ2Y7UUFDaEIseUJBQXlCO1FBQ3pCLElBQUluQixnQkFBZ0JtQyxPQUFPLEVBQUU7WUFDM0JDLGFBQWFwQyxnQkFBZ0JtQyxPQUFPO1FBQ3RDO1FBRUEsZ0NBQWdDO1FBQ2hDbkMsZ0JBQWdCbUMsT0FBTyxHQUFHRSxXQUFXO1lBQ25DLElBQUlqRCxhQUFhK0IsTUFBTTtnQkFDckJELGNBQWNDLE1BQU0zQixhQUFhOEMsS0FBSyxDQUFDdEIsUUFBUWxCLEtBQUs7WUFDdEQ7UUFDRixHQUFHLE9BQU8saUJBQWlCO0lBQzdCO0lBRUEsNkJBQTZCO0lBQzdCYixnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTCxJQUFJZSxnQkFBZ0JtQyxPQUFPLEVBQUU7Z0JBQzNCQyxhQUFhcEMsZ0JBQWdCbUMsT0FBTztZQUN0QztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNML0M7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUc7UUFDQWlCO1FBQ0FRO1FBQ0FPO1FBQ0FDO1FBQ0F6QztRQUNBRjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VQcm9qZWN0U2Vzc2lvbi50cz9lZTZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIFByb2plY3RGb3JtRGF0YSB7XG4gIHByb2plY3ROYW1lOiBzdHJpbmc7XG4gIHByb2plY3REZXNjcmlwdGlvbjogc3RyaW5nO1xuICBidWlsZGluZ1R5cGU6IHN0cmluZztcbiAgc3F1YXJlRm9vdGFnZTogbnVtYmVyO1xuICBudW1iZXJPZkZsb29yczogbnVtYmVyO1xuICBudW1iZXJPZlpvbmVzOiBudW1iZXI7XG4gIGNsaWVudE5hbWU6IHN0cmluZztcbiAgY2xpZW50RW1haWw6IHN0cmluZztcbiAgY2xpZW50UGhvbmU6IHN0cmluZztcbiAgcHJvamVjdExvY2F0aW9uOiBzdHJpbmc7XG4gIGVzdGltYXRlZFN0YXJ0RGF0ZTogc3RyaW5nO1xuICBlc3RpbWF0ZWRFbmREYXRlOiBzdHJpbmc7XG4gIGJ1ZGdldDogbnVtYmVyO1xuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcbn1cblxuaW50ZXJmYWNlIFByb2plY3RTZXNzaW9uIHtcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIHByb2plY3REYXRhOiBQcm9qZWN0Rm9ybURhdGE7XG4gIGN1cnJlbnRTdGVwOiBudW1iZXI7XG4gIGNvbXBsZXRlZFN0ZXBzOiBudW1iZXJbXTtcbiAgdmFsaWRhdGlvblN0YXR1czoge1xuICAgIHN0ZXAxOiBib29sZWFuO1xuICAgIHN0ZXAyOiBib29sZWFuO1xuICAgIHN0ZXAzOiBib29sZWFuO1xuICAgIHN0ZXA0OiBib29sZWFuO1xuICB9O1xuICBjcmVhdGVkQXQ6IERhdGU7XG4gIGxhc3RBY3Rpdml0eTogRGF0ZTtcbiAgZXhwaXJlc0F0OiBEYXRlO1xufVxuXG5leHBvcnQgY29uc3QgdXNlUHJvamVjdFNlc3Npb24gPSAoKSA9PiB7XG4gIGNvbnN0IFtzZXNzaW9uSWQsIHNldFNlc3Npb25JZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Byb2plY3REYXRhLCBzZXRQcm9qZWN0RGF0YV0gPSB1c2VTdGF0ZTxQcm9qZWN0Rm9ybURhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRTdGVwLCBzZXRDdXJyZW50U3RlcF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2NvbXBsZXRlZFN0ZXBzLCBzZXRDb21wbGV0ZWRTdGVwc10gPSB1c2VTdGF0ZTxudW1iZXJbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGF1dG9TYXZlVGltZW91dCA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGNyZWF0ZVNlc3Npb24gPSBhc3luYyAoaW5pdGlhbERhdGE6IFBhcnRpYWw8UHJvamVjdEZvcm1EYXRhPiA9IHt9KSA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wcm9qZWN0LXNlc3Npb24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHByb2plY3REYXRhOiBpbml0aWFsRGF0YSxcbiAgICAgICAgICBjdXJyZW50U3RlcDogMSxcbiAgICAgICAgICBjb21wbGV0ZWRTdGVwczogW11cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgc2Vzc2lvbklkIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBzZXRTZXNzaW9uSWQoc2Vzc2lvbklkKTtcbiAgICAgIHNldFByb2plY3REYXRhKGluaXRpYWxEYXRhIGFzIFByb2plY3RGb3JtRGF0YSk7XG4gICAgICBzZXRDdXJyZW50U3RlcCgxKTtcbiAgICAgIHNldENvbXBsZXRlZFN0ZXBzKFtdKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgc2Vzc2lvbiBJRCBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwcm9qZWN0U2Vzc2lvbklkJywgc2Vzc2lvbklkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHNlc3Npb25JZDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVTZXNzaW9uID0gYXN5bmMgKGRhdGE6IFBhcnRpYWw8UHJvamVjdEZvcm1EYXRhPiwgc3RlcDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uSWQpIHJldHVybjtcbiAgICBcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHsgLi4ucHJvamVjdERhdGEsIC4uLmRhdGEgfTtcbiAgICAgIHNldFByb2plY3REYXRhKHVwZGF0ZWREYXRhKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wcm9qZWN0LXNlc3Npb24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgIHByb2plY3REYXRhOiB1cGRhdGVkRGF0YSxcbiAgICAgICAgICBjdXJyZW50U3RlcDogc3RlcCxcbiAgICAgICAgICBjb21wbGV0ZWRTdGVwczogWy4uLmNvbXBsZXRlZFN0ZXBzLCBzdGVwXVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHNlc3Npb24nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0Q3VycmVudFN0ZXAoc3RlcCk7XG4gICAgICBzZXRDb21wbGV0ZWRTdGVwcyhwcmV2ID0+IEFycmF5LmZyb20obmV3IFNldChbLi4ucHJldiwgc3RlcF0pKSk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbG9hZFNlc3Npb24gPSBhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcHJvamVjdC1zZXNzaW9uLyR7aWR9YCk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgLy8gU2Vzc2lvbiBub3QgZm91bmQsIGNyZWF0ZSBuZXcgb25lXG4gICAgICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gbm90IGZvdW5kLCBjcmVhdGluZyBuZXcgc2Vzc2lvbicpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwcm9qZWN0U2Vzc2lvbklkJyk7XG4gICAgICAgICAgYXdhaXQgY3JlYXRlU2Vzc2lvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQxMCkge1xuICAgICAgICAgIC8vIFNlc3Npb24gZXhwaXJlZCwgY3JlYXRlIG5ldyBvbmVcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiBleHBpcmVkLCBjcmVhdGluZyBuZXcgc2Vzc2lvbicpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwcm9qZWN0U2Vzc2lvbklkJyk7XG4gICAgICAgICAgYXdhaXQgY3JlYXRlU2Vzc2lvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNlc3Npb246ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHNlc3Npb246IFByb2plY3RTZXNzaW9uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBzZXRTZXNzaW9uSWQoc2Vzc2lvbi5zZXNzaW9uSWQpO1xuICAgICAgc2V0UHJvamVjdERhdGEoc2Vzc2lvbi5wcm9qZWN0RGF0YSk7XG4gICAgICBzZXRDdXJyZW50U3RlcChzZXNzaW9uLmN1cnJlbnRTdGVwKTtcbiAgICAgIHNldENvbXBsZXRlZFN0ZXBzKHNlc3Npb24uY29tcGxldGVkU3RlcHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG5ldyBzZXNzaW9uXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncHJvamVjdFNlc3Npb25JZCcpO1xuICAgICAgYXdhaXQgY3JlYXRlU2Vzc2lvbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xlYXJTZXNzaW9uID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChzZXNzaW9uSWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL3Byb2plY3Qtc2Vzc2lvbi8ke3Nlc3Npb25JZH1gLCB7IG1ldGhvZDogJ0RFTEVURScgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwcm9qZWN0U2Vzc2lvbklkJyk7XG4gICAgICBzZXRTZXNzaW9uSWQobnVsbCk7XG4gICAgICBzZXRQcm9qZWN0RGF0YShudWxsKTtcbiAgICAgIHNldEN1cnJlbnRTdGVwKDEpO1xuICAgICAgc2V0Q29tcGxldGVkU3RlcHMoW10pO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGF1dG9TYXZlID0gKGRhdGE6IFBhcnRpYWw8UHJvamVjdEZvcm1EYXRhPikgPT4ge1xuICAgIC8vIENsZWFyIGV4aXN0aW5nIHRpbWVvdXRcbiAgICBpZiAoYXV0b1NhdmVUaW1lb3V0LmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dChhdXRvU2F2ZVRpbWVvdXQuY3VycmVudCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBuZXcgdGltZW91dCBmb3IgYXV0by1zYXZlXG4gICAgYXV0b1NhdmVUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChzZXNzaW9uSWQgJiYgZGF0YSkge1xuICAgICAgICB1cGRhdGVTZXNzaW9uKGRhdGEsIGN1cnJlbnRTdGVwKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgIH1cbiAgICB9LCAxMDAwKTsgLy8gMSBzZWNvbmQgZGVsYXlcbiAgfTtcblxuICAvLyBDbGVhbnVwIHRpbWVvdXQgb24gdW5tb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYXV0b1NhdmVUaW1lb3V0LmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGF1dG9TYXZlVGltZW91dC5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzZXNzaW9uSWQsXG4gICAgcHJvamVjdERhdGEsXG4gICAgY3VycmVudFN0ZXAsXG4gICAgY29tcGxldGVkU3RlcHMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBjcmVhdGVTZXNzaW9uLFxuICAgIHVwZGF0ZVNlc3Npb24sXG4gICAgbG9hZFNlc3Npb24sXG4gICAgY2xlYXJTZXNzaW9uLFxuICAgIGF1dG9TYXZlLFxuICAgIHNldEN1cnJlbnRTdGVwLFxuICAgIHNldFByb2plY3REYXRhXG4gIH07XG59OyAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VQcm9qZWN0U2Vzc2lvbiIsInNlc3Npb25JZCIsInNldFNlc3Npb25JZCIsInByb2plY3REYXRhIiwic2V0UHJvamVjdERhdGEiLCJjdXJyZW50U3RlcCIsInNldEN1cnJlbnRTdGVwIiwiY29tcGxldGVkU3RlcHMiLCJzZXRDb21wbGV0ZWRTdGVwcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImF1dG9TYXZlVGltZW91dCIsImNyZWF0ZVNlc3Npb24iLCJpbml0aWFsRGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJFcnJvciIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJjb25zb2xlIiwibWVzc2FnZSIsInVwZGF0ZVNlc3Npb24iLCJkYXRhIiwic3RlcCIsInVwZGF0ZWREYXRhIiwicHJldiIsIkFycmF5IiwiZnJvbSIsIlNldCIsImxvYWRTZXNzaW9uIiwiaWQiLCJzdGF0dXMiLCJsb2ciLCJyZW1vdmVJdGVtIiwic3RhdHVzVGV4dCIsInNlc3Npb24iLCJjbGVhclNlc3Npb24iLCJhdXRvU2F2ZSIsImN1cnJlbnQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2F0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useProjectSession.ts\n"));

/***/ })

});