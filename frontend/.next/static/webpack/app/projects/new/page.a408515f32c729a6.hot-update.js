"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projects/new/page",{

/***/ "(app-pages-browser)/./hooks/useProjectSession.ts":
/*!************************************!*\
  !*** ./hooks/useProjectSession.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProjectSession: function() { return /* binding */ useProjectSession; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useProjectSession = ()=>{\n    const [sessionId, setSessionId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [projectData, setProjectData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentStep, setCurrentStep] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [completedSteps, setCompletedSteps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const autoSaveTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const createSession = async function() {\n        let initialData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        setLoading(true);\n        setError(null);\n        try {\n            const response = await fetch(\"/api/project-session\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    projectData: initialData,\n                    currentStep: 1,\n                    completedSteps: []\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to create session\");\n            }\n            const { sessionId } = await response.json();\n            setSessionId(sessionId);\n            setProjectData(initialData);\n            setCurrentStep(1);\n            setCompletedSteps([]);\n            // Store session ID in localStorage\n            localStorage.setItem(\"projectSessionId\", sessionId);\n            return sessionId;\n        } catch (error) {\n            console.error(\"Error creating session:\", error);\n            setError(error.message);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const updateSession = async (data, step)=>{\n        if (!sessionId) return;\n        setLoading(true);\n        setError(null);\n        try {\n            const updatedData = {\n                ...projectData,\n                ...data\n            };\n            setProjectData(updatedData);\n            const response = await fetch(\"/api/project-session\", {\n                method: \"PUT\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    sessionId,\n                    projectData: updatedData,\n                    currentStep: step || currentStep,\n                    completedSteps: step ? [\n                        ...completedSteps,\n                        step\n                    ] : completedSteps\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to update session\");\n            }\n            if (step) {\n                setCurrentStep(step);\n                setCompletedSteps((prev)=>Array.from(new Set([\n                        ...prev,\n                        step\n                    ])));\n            }\n        } catch (error) {\n            console.error(\"Error updating session:\", error);\n            setError(error.message);\n            throw error;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const loadSession = async (id)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            var _session_projectData;\n            console.log(\"Loading session with ID:\", id);\n            const response = await fetch(\"/api/project-session/\".concat(id));\n            if (!response.ok) {\n                if (response.status === 404) {\n                    // Session not found, create new one\n                    console.log(\"Session not found, creating new session\");\n                    localStorage.removeItem(\"projectSessionId\");\n                    await createSession();\n                    return;\n                } else if (response.status === 410) {\n                    // Session expired, create new one\n                    console.log(\"Session expired, creating new session\");\n                    localStorage.removeItem(\"projectSessionId\");\n                    await createSession();\n                    return;\n                }\n                throw new Error(\"Failed to load session: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            const session = await response.json();\n            console.log(\"Loaded session data:\", session);\n            console.log(\"Session projectData:\", session.projectData);\n            console.log(\"Session uploadedFiles:\", (_session_projectData = session.projectData) === null || _session_projectData === void 0 ? void 0 : _session_projectData.uploadedFiles);\n            setSessionId(session.sessionId);\n            setProjectData(session.projectData);\n            setCurrentStep(session.currentStep);\n            setCompletedSteps(session.completedSteps);\n        } catch (error) {\n            console.error(\"Error loading session:\", error);\n            setError(error.message);\n            // Fallback to new session\n            localStorage.removeItem(\"projectSessionId\");\n            await createSession();\n        } finally{\n            setLoading(false);\n        }\n    };\n    const clearSession = async ()=>{\n        if (sessionId) {\n            try {\n                await fetch(\"/api/project-session/\".concat(sessionId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error clearing session:\", error);\n            }\n            localStorage.removeItem(\"projectSessionId\");\n            setSessionId(null);\n            setProjectData(null);\n            setCurrentStep(1);\n            setCompletedSteps([]);\n            setError(null);\n        }\n    };\n    const autoSave = (data)=>{\n        // Clear existing timeout\n        if (autoSaveTimeout.current) {\n            clearTimeout(autoSaveTimeout.current);\n        }\n        // Set new timeout for auto-save\n        autoSaveTimeout.current = setTimeout(()=>{\n            if (sessionId && data) {\n                updateSession(data, currentStep).catch(console.error);\n            }\n        }, 1000); // 1 second delay\n    };\n    // Cleanup timeout on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (autoSaveTimeout.current) {\n                clearTimeout(autoSaveTimeout.current);\n            }\n        };\n    }, []);\n    return {\n        sessionId,\n        projectData,\n        currentStep,\n        completedSteps,\n        loading,\n        error,\n        createSession,\n        updateSession,\n        loadSession,\n        clearSession,\n        autoSave,\n        setCurrentStep,\n        setProjectData\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVByb2plY3RTZXNzaW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRDtBQTRDN0MsTUFBTUcsb0JBQW9CO0lBQy9CLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHTCwrQ0FBUUEsQ0FBZ0I7SUFDMUQsTUFBTSxDQUFDTSxhQUFhQyxlQUFlLEdBQUdQLCtDQUFRQSxDQUF5QjtJQUN2RSxNQUFNLENBQUNRLGFBQWFDLGVBQWUsR0FBR1QsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDVSxnQkFBZ0JDLGtCQUFrQixHQUFHWCwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ2pFLE1BQU0sQ0FBQ1ksU0FBU0MsV0FBVyxHQUFHYiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNjLE9BQU9DLFNBQVMsR0FBR2YsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU1nQixrQkFBa0JkLDZDQUFNQSxDQUF3QjtJQUV0RCxNQUFNZSxnQkFBZ0I7WUFBT0MsK0VBQXdDLENBQUM7UUFDcEVMLFdBQVc7UUFDWEUsU0FBUztRQUVULElBQUk7WUFDRixNQUFNSSxXQUFXLE1BQU1DLE1BQU0sd0JBQXdCO2dCQUNuREMsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQm5CLGFBQWFZO29CQUNiVixhQUFhO29CQUNiRSxnQkFBZ0IsRUFBRTtnQkFDcEI7WUFDRjtZQUVBLElBQUksQ0FBQ1MsU0FBU08sRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1SLFNBQVNTLElBQUk7Z0JBQ3JDLE1BQU0sSUFBSUMsTUFBTUYsVUFBVWIsS0FBSyxJQUFJO1lBQ3JDO1lBRUEsTUFBTSxFQUFFVixTQUFTLEVBQUUsR0FBRyxNQUFNZSxTQUFTUyxJQUFJO1lBQ3pDdkIsYUFBYUQ7WUFDYkcsZUFBZVc7WUFDZlQsZUFBZTtZQUNmRSxrQkFBa0IsRUFBRTtZQUVwQixtQ0FB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QkgsYUFBYWlCLFVBQVUsQ0FBQztZQUN4QixNQUFNOUI7UUFDUixTQUFVO1lBQ1JKLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTXFDLGVBQWU7UUFDbkIsSUFBSTlDLFdBQVc7WUFDYixJQUFJO2dCQUNGLE1BQU1nQixNQUFNLHdCQUFrQyxPQUFWaEIsWUFBYTtvQkFBRWlCLFFBQVE7Z0JBQVM7WUFDdEUsRUFBRSxPQUFPUCxPQUFPO2dCQUNka0IsUUFBUWxCLEtBQUssQ0FBQywyQkFBMkJBO1lBQzNDO1lBQ0FnQixhQUFhaUIsVUFBVSxDQUFDO1lBQ3hCMUMsYUFBYTtZQUNiRSxlQUFlO1lBQ2ZFLGVBQWU7WUFDZkUsa0JBQWtCLEVBQUU7WUFDcEJJLFNBQVM7UUFDWDtJQUNGO0lBRUEsTUFBTW9DLFdBQVcsQ0FBQ2hCO1FBQ2hCLHlCQUF5QjtRQUN6QixJQUFJbkIsZ0JBQWdCb0MsT0FBTyxFQUFFO1lBQzNCQyxhQUFhckMsZ0JBQWdCb0MsT0FBTztRQUN0QztRQUVBLGdDQUFnQztRQUNoQ3BDLGdCQUFnQm9DLE9BQU8sR0FBR0UsV0FBVztZQUNuQyxJQUFJbEQsYUFBYStCLE1BQU07Z0JBQ3JCRCxjQUFjQyxNQUFNM0IsYUFBYStDLEtBQUssQ0FBQ3ZCLFFBQVFsQixLQUFLO1lBQ3REO1FBQ0YsR0FBRyxPQUFPLGlCQUFpQjtJQUM3QjtJQUVBLDZCQUE2QjtJQUM3QmIsZ0RBQVNBLENBQUM7UUFDUixPQUFPO1lBQ0wsSUFBSWUsZ0JBQWdCb0MsT0FBTyxFQUFFO2dCQUMzQkMsYUFBYXJDLGdCQUFnQm9DLE9BQU87WUFDdEM7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU87UUFDTGhEO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FHO1FBQ0FpQjtRQUNBUTtRQUNBUTtRQUNBQztRQUNBMUM7UUFDQUY7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlUHJvamVjdFNlc3Npb24udHM/ZWU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBQcm9qZWN0Rm9ybURhdGEge1xuICBwcm9qZWN0TmFtZTogc3RyaW5nO1xuICBwcm9qZWN0RGVzY3JpcHRpb246IHN0cmluZztcbiAgYnVpbGRpbmdUeXBlOiBzdHJpbmc7XG4gIHNxdWFyZUZvb3RhZ2U6IG51bWJlcjtcbiAgbnVtYmVyT2ZGbG9vcnM6IG51bWJlcjtcbiAgbnVtYmVyT2Zab25lczogbnVtYmVyO1xuICBjbGllbnROYW1lOiBzdHJpbmc7XG4gIGNsaWVudEVtYWlsOiBzdHJpbmc7XG4gIGNsaWVudFBob25lOiBzdHJpbmc7XG4gIHByb2plY3RMb2NhdGlvbjogc3RyaW5nO1xuICBlc3RpbWF0ZWRTdGFydERhdGU6IHN0cmluZztcbiAgZXN0aW1hdGVkRW5kRGF0ZTogc3RyaW5nO1xuICBidWRnZXQ6IG51bWJlcjtcbiAgcHJpb3JpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCc7XG4gIHVwbG9hZGVkRmlsZXM/OiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc2l6ZTogbnVtYmVyO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICB1cmw6IHN0cmluZztcbiAgICBzdGF0dXM6ICd1cGxvYWRpbmcnIHwgJ3N1Y2Nlc3MnIHwgJ2Vycm9yJztcbiAgICBlcnJvcj86IHN0cmluZztcbiAgfT47XG59XG5cbmludGVyZmFjZSBQcm9qZWN0U2Vzc2lvbiB7XG4gIHNlc3Npb25JZDogc3RyaW5nO1xuICBwcm9qZWN0RGF0YTogUHJvamVjdEZvcm1EYXRhO1xuICBjdXJyZW50U3RlcDogbnVtYmVyO1xuICBjb21wbGV0ZWRTdGVwczogbnVtYmVyW107XG4gIHZhbGlkYXRpb25TdGF0dXM6IHtcbiAgICBzdGVwMTogYm9vbGVhbjtcbiAgICBzdGVwMjogYm9vbGVhbjtcbiAgICBzdGVwMzogYm9vbGVhbjtcbiAgICBzdGVwNDogYm9vbGVhbjtcbiAgfTtcbiAgY3JlYXRlZEF0OiBEYXRlO1xuICBsYXN0QWN0aXZpdHk6IERhdGU7XG4gIGV4cGlyZXNBdDogRGF0ZTtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVByb2plY3RTZXNzaW9uID0gKCkgPT4ge1xuICBjb25zdCBbc2Vzc2lvbklkLCBzZXRTZXNzaW9uSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwcm9qZWN0RGF0YSwgc2V0UHJvamVjdERhdGFdID0gdXNlU3RhdGU8UHJvamVjdEZvcm1EYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50U3RlcCwgc2V0Q3VycmVudFN0ZXBdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtjb21wbGV0ZWRTdGVwcywgc2V0Q29tcGxldGVkU3RlcHNdID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBhdXRvU2F2ZVRpbWVvdXQgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKGluaXRpYWxEYXRhOiBQYXJ0aWFsPFByb2plY3RGb3JtRGF0YT4gPSB7fSkgPT4ge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcHJvamVjdC1zZXNzaW9uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm9qZWN0RGF0YTogaW5pdGlhbERhdGEsXG4gICAgICAgICAgY3VycmVudFN0ZXA6IDEsXG4gICAgICAgICAgY29tcGxldGVkU3RlcHM6IFtdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgc2Vzc2lvbicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IHNlc3Npb25JZCB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2V0U2Vzc2lvbklkKHNlc3Npb25JZCk7XG4gICAgICBzZXRQcm9qZWN0RGF0YShpbml0aWFsRGF0YSBhcyBQcm9qZWN0Rm9ybURhdGEpO1xuICAgICAgc2V0Q3VycmVudFN0ZXAoMSk7XG4gICAgICBzZXRDb21wbGV0ZWRTdGVwcyhbXSk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHNlc3Npb24gSUQgaW4gbG9jYWxTdG9yYWdlXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncHJvamVjdFNlc3Npb25JZCcsIHNlc3Npb25JZCk7XG4gICAgICBcbiAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlU2Vzc2lvbiA9IGFzeW5jIChkYXRhOiBQYXJ0aWFsPFByb2plY3RGb3JtRGF0YT4sIHN0ZXA/OiBudW1iZXIpID0+IHtcbiAgICBpZiAoIXNlc3Npb25JZCkgcmV0dXJuO1xuICAgIFxuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0geyAuLi5wcm9qZWN0RGF0YSwgLi4uZGF0YSB9O1xuICAgICAgc2V0UHJvamVjdERhdGEodXBkYXRlZERhdGEpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Byb2plY3Qtc2Vzc2lvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgcHJvamVjdERhdGE6IHVwZGF0ZWREYXRhLFxuICAgICAgICAgIGN1cnJlbnRTdGVwOiBzdGVwIHx8IGN1cnJlbnRTdGVwLFxuICAgICAgICAgIGNvbXBsZXRlZFN0ZXBzOiBzdGVwID8gWy4uLmNvbXBsZXRlZFN0ZXBzLCBzdGVwXSA6IGNvbXBsZXRlZFN0ZXBzXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgc2Vzc2lvbicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoc3RlcCkge1xuICAgICAgICBzZXRDdXJyZW50U3RlcChzdGVwKTtcbiAgICAgICAgc2V0Q29tcGxldGVkU3RlcHMocHJldiA9PiBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLnByZXYsIHN0ZXBdKSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHNlc3Npb246JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGxvYWRTZXNzaW9uID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBzZXNzaW9uIHdpdGggSUQ6JywgaWQpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9wcm9qZWN0LXNlc3Npb24vJHtpZH1gKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAvLyBTZXNzaW9uIG5vdCBmb3VuZCwgY3JlYXRlIG5ldyBvbmVcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiBub3QgZm91bmQsIGNyZWF0aW5nIG5ldyBzZXNzaW9uJyk7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Byb2plY3RTZXNzaW9uSWQnKTtcbiAgICAgICAgICBhd2FpdCBjcmVhdGVTZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDEwKSB7XG4gICAgICAgICAgLy8gU2Vzc2lvbiBleHBpcmVkLCBjcmVhdGUgbmV3IG9uZVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIGV4cGlyZWQsIGNyZWF0aW5nIG5ldyBzZXNzaW9uJyk7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Byb2plY3RTZXNzaW9uSWQnKTtcbiAgICAgICAgICBhd2FpdCBjcmVhdGVTZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2Vzc2lvbjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2Vzc2lvbjogUHJvamVjdFNlc3Npb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnTG9hZGVkIHNlc3Npb24gZGF0YTonLCBzZXNzaW9uKTtcbiAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHByb2plY3REYXRhOicsIHNlc3Npb24ucHJvamVjdERhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gdXBsb2FkZWRGaWxlczonLCBzZXNzaW9uLnByb2plY3REYXRhPy51cGxvYWRlZEZpbGVzKTtcbiAgICAgIFxuICAgICAgc2V0U2Vzc2lvbklkKHNlc3Npb24uc2Vzc2lvbklkKTtcbiAgICAgIHNldFByb2plY3REYXRhKHNlc3Npb24ucHJvamVjdERhdGEpO1xuICAgICAgc2V0Q3VycmVudFN0ZXAoc2Vzc2lvbi5jdXJyZW50U3RlcCk7XG4gICAgICBzZXRDb21wbGV0ZWRTdGVwcyhzZXNzaW9uLmNvbXBsZXRlZFN0ZXBzKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNlc3Npb246JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAvLyBGYWxsYmFjayB0byBuZXcgc2Vzc2lvblxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Byb2plY3RTZXNzaW9uSWQnKTtcbiAgICAgIGF3YWl0IGNyZWF0ZVNlc3Npb24oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNsZWFyU2Vzc2lvbiA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoc2Vzc2lvbklkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9wcm9qZWN0LXNlc3Npb24vJHtzZXNzaW9uSWR9YCwgeyBtZXRob2Q6ICdERUxFVEUnIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncHJvamVjdFNlc3Npb25JZCcpO1xuICAgICAgc2V0U2Vzc2lvbklkKG51bGwpO1xuICAgICAgc2V0UHJvamVjdERhdGEobnVsbCk7XG4gICAgICBzZXRDdXJyZW50U3RlcCgxKTtcbiAgICAgIHNldENvbXBsZXRlZFN0ZXBzKFtdKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhdXRvU2F2ZSA9IChkYXRhOiBQYXJ0aWFsPFByb2plY3RGb3JtRGF0YT4pID0+IHtcbiAgICAvLyBDbGVhciBleGlzdGluZyB0aW1lb3V0XG4gICAgaWYgKGF1dG9TYXZlVGltZW91dC5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQoYXV0b1NhdmVUaW1lb3V0LmN1cnJlbnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgbmV3IHRpbWVvdXQgZm9yIGF1dG8tc2F2ZVxuICAgIGF1dG9TYXZlVGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoc2Vzc2lvbklkICYmIGRhdGEpIHtcbiAgICAgICAgdXBkYXRlU2Vzc2lvbihkYXRhLCBjdXJyZW50U3RlcCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICB9XG4gICAgfSwgMTAwMCk7IC8vIDEgc2Vjb25kIGRlbGF5XG4gIH07XG5cbiAgLy8gQ2xlYW51cCB0aW1lb3V0IG9uIHVubW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGF1dG9TYXZlVGltZW91dC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhdXRvU2F2ZVRpbWVvdXQuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgc2Vzc2lvbklkLFxuICAgIHByb2plY3REYXRhLFxuICAgIGN1cnJlbnRTdGVwLFxuICAgIGNvbXBsZXRlZFN0ZXBzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgY3JlYXRlU2Vzc2lvbixcbiAgICB1cGRhdGVTZXNzaW9uLFxuICAgIGxvYWRTZXNzaW9uLFxuICAgIGNsZWFyU2Vzc2lvbixcbiAgICBhdXRvU2F2ZSxcbiAgICBzZXRDdXJyZW50U3RlcCxcbiAgICBzZXRQcm9qZWN0RGF0YVxuICB9O1xufTsgIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlUHJvamVjdFNlc3Npb24iLCJzZXNzaW9uSWQiLCJzZXRTZXNzaW9uSWQiLCJwcm9qZWN0RGF0YSIsInNldFByb2plY3REYXRhIiwiY3VycmVudFN0ZXAiLCJzZXRDdXJyZW50U3RlcCIsImNvbXBsZXRlZFN0ZXBzIiwic2V0Q29tcGxldGVkU3RlcHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJhdXRvU2F2ZVRpbWVvdXQiLCJjcmVhdGVTZXNzaW9uIiwiaW5pdGlhbERhdGEiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiRXJyb3IiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiY29uc29sZSIsIm1lc3NhZ2UiLCJ1cGRhdGVTZXNzaW9uIiwiZGF0YSIsInN0ZXAiLCJ1cGRhdGVkRGF0YSIsInByZXYiLCJBcnJheSIsImZyb20iLCJTZXQiLCJsb2FkU2Vzc2lvbiIsImlkIiwic2Vzc2lvbiIsImxvZyIsInN0YXR1cyIsInJlbW92ZUl0ZW0iLCJzdGF0dXNUZXh0IiwidXBsb2FkZWRGaWxlcyIsImNsZWFyU2Vzc2lvbiIsImF1dG9TYXZlIiwiY3VycmVudCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useProjectSession.ts\n"));

/***/ })

});